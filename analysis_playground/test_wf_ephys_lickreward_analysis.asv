%% Get behavior times

lick_bout_cutoff = 1; % seconds between what's considered a lick bout
lick_bout_times = signals_events.n_licksTimes([1,find(diff( ...
    signals_events.n_licksTimes) >= lick_bout_cutoff)+1]);

min_lick_to_reward_time = 0.01; % time from lick to reward to define rewarded lick
lick_to_reward_time = min(abs(bsxfun(@minus,lick_bout_times',signals_events.hitTimes)),[],2);
rewarded_licks = lick_to_reward_time < min_lick_to_reward_time;

n_complete_stim = min(length(signals_events.stimOnTimes),length(signals_events.stimOffTimes));
stimOnTimes = signals_events.stimOnTimes(1:n_complete_stim);
stimOffTimes = signals_events.stimOffTimes(1:n_complete_stim);
azimuths = signals_events.trialAzimuthValues(1:n_complete_stim);

epoch_times = reshape([stimOnTimes;stimOffTimes],[],1);
epoch_hit = histcounts(signals_events.hitTimes,epoch_times) > 0;
stim_hit = epoch_hit(1:2:end);

stim_hit_licktime_cell = arrayfun(@(x) signals_events.n_licksTimes(find(...
    signals_events.n_licksTimes >= stimOnTimes(x) & ...
    signals_events.n_licksTimes <= stimOffTimes(x),1)),1:length(stimOnTimes),'uni',false);
stim_hit_licktime = nan(size(stim_hit));
stim_hit_licktime(stim_hit) = [stim_hit_licktime_cell{stim_hit}];

%% Get visual striatum MUA PSTH around events

use_spikes_idx = ismember(spike_templates,find(templateDepths >= 0 & templateDepths <= 2000));

use_spikes = spike_times_timeline(use_spikes_idx);

align_times = stimOnTimes(stim_hit & azimuths == 90);
%align_times = stim_hit_licktime(stim_hit & azimuths == 0);
%align_times = lick_bout_times(~rewarded_licks);

raster_window = [-0.5,3.5];
psth_bin_size = 0.001;
[psth,bins,rasterX,rasterY,spikeCounts] = psthAndBA( ...
    use_spikes,align_times, ...
    raster_window, psth_bin_size);

smooth_size = 50;
gw = gausswin(smooth_size,3)';
smWin = gw./sum(gw);
psth_smooth = conv2(psth,smWin,'same');
figure; hold on;
plot(bins(20:end-20),psth_smooth(20:end-20)','k','linewidth',2);
line([0,0],ylim,'linestyle','--','color','k');
ylabel('Population spikes');
xlabel('Time from stim onset')

%% Average fluorescence around stuff

% Define the window to get an aligned response to
surround_window = [-1,4];

align_times = stimOnTimes(stim_hit & azimuths == 0);
%align_times = lick_bout_times(~rewarded_licks);

% Get the surround time
framerate = 1./nanmedian(diff(frame_t));
surround_samplerate = 1/(framerate*1);
surround_time = surround_window(1):surround_samplerate:surround_window(2);

% Don't use times that fall outside of imaging
align_times(align_times + surround_time(1) < frame_t(2) | ...
    align_times + surround_time(2) > frame_t(end)) = [];

% Use closest frames to times
align_surround_times = bsxfun(@plus, align_times', surround_time);
frame_edges = [frame_t,frame_t(end)+1/framerate];
align_frames = discretize(align_surround_times,frame_edges);

% If any aligned V's are NaNs (when does this happen?), don't use
align_frames(any(isnan(align_frames),2),:) = [];

aligned_V = reshape(fV(:,align_frames'), ...
    size(fV,1),size(align_frames,2),size(align_frames,1));

mean_aligned_V = nanmean(aligned_V,3);

% Get and plot the average fluorescence around event
mean_aligned_px = svdFrameReconstruct(U,mean_aligned_V);

AP_image_scroll(mean_aligned_px,surround_time);
warning off; truesize; warning on;

%% Regress stuff to fluorescence

% Skip the first n seconds to do this
skip_seconds = 10;
use_frames = (frame_t > skip_seconds);

% Bin choiceworld events by frame
frame_edges = [frame_t,frame_t(end)+1/framerate];
signals_event_trace = [];

% Stim
azimuths = unique(signals_events.trialAzimuthValues);
for trialAzimuth_idx = 1:length(azimuths)        
        curr_azimuth = azimuths(trialAzimuth_idx);       
        use_trials = signals_events.trialAzimuthValues == curr_azimuth;
        align_times = signals_events.stimOnTimes(use_trials(1:length(signals_events.stimOnTimes)))';
        signals_event_trace = [signals_event_trace;histcounts(align_times,frame_edges)];        
end
% Licks
frame_licks = histcounts(signals_events.n_licksTimes,frame_edges);
signals_event_trace = [signals_event_trace;frame_licks];
% Rewards
water_name = 'rewardEcho';
water_idx = strcmp({Timeline.hw.inputs.name}, water_name);
water_times = Timeline.rawDAQTimestamps(find(Timeline.rawDAQData(1:end-1,water_idx) <= 2 & ...
    Timeline.rawDAQData(2:end,water_idx) > 2) + 1);
frame_water = histcounts(water_times,frame_edges);
signals_event_trace = [signals_event_trace;frame_water];

use_svs = 1:50;
kernel_frames = -7:35*4;
lambda = 0;
zs = false;
cvfold = 5;

[k,predicted_fluor,explained_var] = ...
    AP_regresskernel(signals_event_trace(:,use_frames), ...
    fV(use_svs,use_frames), ...
    kernel_frames,lambda,zs,cvfold);

% Reshape kernel and convert to pixel space
k_r = permute(reshape(k,size(signals_event_trace,1),length(kernel_frames),length(use_svs)),[3,2,1]);

r_px = zeros(size(U,1),size(U,2),size(k_r,2),size(k_r,3),'single');
for curr_event = 1:size(k_r,3);
    r_px(:,:,:,curr_event) = svdFrameReconstruct(U(:,:,use_svs),k_r(:,:,curr_event));
end

AP_image_scroll(r_px,kernel_frames/framerate);
caxis([prctile(r_px(:),[1,99])]*4);
truesize

%% Regress fluorescence to stuff

% Skip the first n seconds to do this
skip_seconds = 10;
use_frames = (frame_t > skip_seconds);

% Bin choiceworld events by frame
frame_edges = [frame_t,frame_t(end)+1/framerate];
signals_event_trace = [];

% Stim
azimuths = unique(signals_events.trialAzimuthValues);
for trialAzimuth_idx = 1:length(azimuths)        
        curr_azimuth = azimuths(trialAzimuth_idx);       
        use_trials = signals_events.trialAzimuthValues == curr_azimuth;
        align_times = signals_events.stimOnTimes(use_trials(1:length(signals_events.stimOnTimes)))';
        signals_event_trace = [signals_event_trace;histcounts(align_times,frame_edges)];        
end
% Licks
frame_licks = histcounts(signals_events.n_licksTimes,frame_edges);
signals_event_trace = [signals_event_trace;frame_licks];
% Rewards
water_name = 'rewardEcho';
water_idx = strcmp({Timeline.hw.inputs.name}, water_name);
water_times = Timeline.rawDAQTimestamps(find(Timeline.rawDAQData(1:end-1,water_idx) <= 2 & ...
    Timeline.rawDAQData(2:end,water_idx) > 2) + 1);
frame_water = histcounts(water_times,frame_edges);
signals_event_trace = [signals_event_trace;frame_water];

use_svs = 1:50;
kernel_frames = -35:7;
lambda = 1e6;
zs = false;
cvfold = 5;

[k,predicted_fluor,explained_var] = ...
    AP_regresskernel(fV(use_svs,use_frames), ...
    signals_event_trace(:,use_frames), ...
    kernel_frames,lambda,zs,cvfold);

% Reshape kernel and convert to pixel space
r = reshape(k,length(use_svs),length(kernel_frames),size(signals_event_trace,1));

r_px = zeros(size(U,1),size(U,2),size(r,2),size(r,3),'single');
for curr_spikes = 1:size(r,3);
    r_px(:,:,:,curr_spikes) = svdFrameReconstruct(U(:,:,use_svs),r(:,:,curr_spikes));
end

AP_image_scroll(r_px,(kernel_frames)/framerate);
caxis([prctile(r_px(:),[1,99])]*4);
truesize


%% Predict lick bout times from fluorescence

% Skip the first n seconds to do this
skip_seconds = 0;
use_frames = (frame_t > skip_seconds);

% Bin choiceworld events by frame
frame_edges = [frame_t,frame_t(end)+1/framerate];
signals_event_trace = [];
   
% Licks
frame_licks = histcounts(lick_bout_times,frame_edges);
signals_event_trace = [signals_event_trace;frame_licks];

use_svs = 1:50;
kernel_frames = 0:15;
lambda = 1e7;
zs = false;
cvfold = 5;

[k,predicted_licks,explained_var] = ...
    AP_regresskernel(fV(use_svs,use_frames), ...
    signals_event_trace(:,use_frames), ...
    kernel_frames,lambda,zs,cvfold);

% Reshape kernel and convert to pixel space
r = reshape(k,length(use_svs),length(kernel_frames),size(signals_event_trace,1));

r_px = zeros(size(U,1),size(U,2),size(r,2),size(r,3),'single');
for curr_spikes = 1:size(r,3);
    r_px(:,:,:,curr_spikes) = svdFrameReconstruct(U(:,:,use_svs),r(:,:,curr_spikes));
end

AP_image_scroll(r_px,(kernel_frames)/framerate);
caxis([prctile(r_px(:),[1,99])]*4);
truesize


%% Rasters/PSTHs around licks

lick_id = rewarded_licks;
lick_id(rewarded_licks & 

raster_window = [-0.5,5];
psthViewer(use_spikes,use_spike_templates, ...
    lick_bout_times,raster_window,stimIDs);










